<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #f0f0f0; }
        canvas { display: block; }
        #dynamic-island {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 35px;
            background: #000;
            border-radius: 20px;
            z-index: 2;
        }
    </style>
</head>
<body>
    <div id="dynamic-island"></div>
    <canvas id="canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script>
        const Engine = Matter.Engine,
            Render = Matter.Render,
            World = Matter.World,
            Bodies = Matter.Bodies,
            Body = Matter.Body;

        const engine = Engine.create();
        const canvas = document.getElementById('canvas');
        const render = Render.create({
            element: document.body,
            engine: engine,
            canvas: canvas,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: 'transparent'
            }
        });

        // Physics setup
        engine.world.gravity.y = 0; // We'll handle custom gravity
        const walls = createWalls();
        World.add(engine.world, walls);

        // Dynamic Island obstacle
        const island = Bodies.rectangle(
            window.innerWidth/2, 50,
            120, 35,
            {
                isStatic: true,
                chamfer: { radius: 15 },
                render: { fillStyle: '#000000' }
            }
        );
        World.add(engine.world, island);

        // Ball creation
        let balls = [];
        const createBall = (x, y) => {
            return Bodies.circle(x, y, 8, {
                restitution: 0.6,
                friction: 0.1,
                density: 0.04,
                render: {
                    fillStyle: '#FFD700'
                }
            });
        };

        // Initial drop
        let ballsDropped = 0;
        const dropInterval = setInterval(() => {
            if(ballsDropped < 50) {
                const ball = createBall(window.innerWidth/2, -20);
                balls.push(ball);
                World.add(engine.world, ball);
                ballsDropped++;
            } else {
                clearInterval(dropInterval);
            }
        }, 100);

        // Device motion handling
        let beta = 0;
        let gamma = 0;

        window.addEventListener('deviceorientation', (e) => {
            beta = e.beta;  // Front/back tilt (y-axis)
            gamma = e.gamma; // Left/right tilt (x-axis)
        });

        // Physics update
        Matter.Events.on(engine, 'beforeUpdate', () => {
            const gravityScale = 0.5;
            
            balls.forEach(ball => {
                // Apply custom gravity based on device orientation
                Body.applyForce(ball, ball.position, {
                    x: Math.sin(gamma * Math.PI / 180) * gravityScale,
                    y: Math.sin(beta * Math.PI / 180) * gravityScale
                });
            });
        });

        // Walls creation
        function createWalls() {
            return [
                Bodies.rectangle(0, window.innerHeight/2, 2, window.innerHeight, { // Left
                    isStatic: true, render: { visible: false }
                }),
                Bodies.rectangle(window.innerWidth, window.innerHeight/2, 2, window.innerHeight, { // Right
                    isStatic: true, render: { visible: false }
                }),
                Bodies.rectangle(window.innerWidth/2, window.innerHeight, window.innerWidth, 2, { // Bottom
                    isStatic: true, render: { visible: false }
                })
            ];
        }

        // Start the engine
        Engine.run(engine);
        Render.run(render);

        // Handle resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render.options.width = window.innerWidth;
            render.options.height = window.innerHeight;
        });
    </script>
</body>
</html>
